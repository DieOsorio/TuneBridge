CREATE OR REPLACE FUNCTION public.notify_comment()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO social.notifications (
        id,
        created_at,
        profile_id,
        type,
        entity_id,
        from_user_id,
        is_read,
        message
    )
    VALUES (
        gen_random_uuid(),
        NOW(),
        (SELECT profile_id FROM social.posts WHERE id = NEW.post_id), -- Post owner
        'comment',
        NEW.post_id, -- The ID of the commented post
        NEW.profile_id, -- The user who commented
        false,
        'Someone commented on your post!'
    );
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.notify_follow_request()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO social.notifications (
        id,
        created_at,
        profile_id,
        type,
        entity_id,
        from_user_id,
        is_read,
        message
    )
    VALUES (
        gen_random_uuid(),
        NOW(),
        NEW.following_profile_id, -- The recipient of the follow request
        'follow_request',
        NEW.id, -- The ID of the user_connections row
        NEW.follower_profile_id, -- The user who sent the follow request
        false,
        'You have a new follow request!'
    );
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.notify_like()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO social.notifications (
        id,
        created_at,
        profile_id,
        type,
        entity_id,
        from_user_id,
        is_read,
        message
    )
    VALUES (
        gen_random_uuid(),
        NOW(),
        (SELECT profile_id FROM social.posts WHERE id = NEW.post_id), -- Post owner
        'like',
        NEW.post_id, -- The ID of the liked post
        NEW.profile_id, -- The user who liked the post
        false,
        'Someone liked your post!'
    );
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.notify_profile_group_join()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO social.notifications (
    id,
    created_at,
    profile_id,
    type,
    entity_id,
    from_user_id,
    is_read,
    message
  )
  VALUES (
    gen_random_uuid(),
    NOW(),
    NEW.profile_id, -- Notify the user (profile_id) who joined the group
    'group_join',
    NEW.profile_group_id, -- The ID of the group
    NEW.profile_id, -- The user who joined the group
    FALSE,
    'You have joined the group.'
  );
  RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.notify_profile_group_leave()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO social.notifications (
    id,
    created_at,
    profile_id,
    type,
    entity_id,
    from_user_id,
    is_read,
    message
  )
  VALUES (
    gen_random_uuid(),
    NOW(),
    OLD.profile_group_id, -- or each admin
    'group_leave',
    OLD.profile_group_id,
    OLD.profile_id,
    FALSE,
    'A member has left the group.'
  );
  RETURN OLD;
END;
$function$



CREATE OR REPLACE FUNCTION public.prevent_duplicate_likes()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF EXISTS (
        SELECT 1
        FROM social.likes
        WHERE profile_id = NEW.profile_id
        AND (post_id = NEW.post_id OR comment_id = NEW.comment_id)
    ) THEN
        RAISE EXCEPTION 'Duplicate like detected';
    END IF;
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.prevent_duplicate_participants()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF EXISTS (
        SELECT 1
        FROM social.conversation_participants
        WHERE conversation_id = NEW.conversation_id
        AND profile_id = NEW.profile_id
    ) THEN
        RAISE EXCEPTION 'Duplicate participant detected';
    END IF;
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.prevent_duplicate_usernames()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF EXISTS (
        SELECT 1
        FROM users.profiles
        WHERE username = NEW.username
        AND id != NEW.id
    ) THEN
        RAISE EXCEPTION 'Duplicate username detected';
    END IF;
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.reassign_admin_on_leave()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  remaining_admins INT;
  new_admin UUID;
BEGIN
  -- Count remaining admins in the group
  SELECT COUNT(*) INTO remaining_admins
  FROM users.profile_group_members
  WHERE profile_group_id = OLD.profile_group_id AND role = 'admin' AND profile_id != OLD.profile_id;

  -- If no admins left, assign a new one
  IF remaining_admins = 0 THEN
    SELECT profile_id INTO new_admin
    FROM users.profile_group_members
    WHERE profile_group_id = OLD.profile_group_id
    ORDER BY joined_at ASC
    LIMIT 1;

    IF new_admin IS NOT NULL THEN
      UPDATE users.profile_group_members
      SET role = 'admin'
      WHERE profile_group_id = OLD.profile_group_id AND profile_id = new_admin;
    END IF;
  END IF;

  RETURN OLD;
END;
$function$



CREATE OR REPLACE FUNCTION public.soft_delete_message()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.deleted_at = NOW();
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.update_comment_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.update_connection_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.update_message_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION public.update_post_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$



CREATE OR REPLACE FUNCTION add_creator_to_group_members()
RETURNS TRIGGER AS $$
BEGIN
  -- Insert the creator into the profile_group_members table
  INSERT INTO users.profile_group_members (profile_group_id, profile_id, role, joined_at)
  VALUES (NEW.id, NEW.created_by, 'admin', NOW());

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION users.update_profile_content_search()
RETURNS TRIGGER AS $$
BEGIN
  NEW.content_search :=
    to_tsvector('spanish', coalesce(NEW.username, '')) ||
    to_tsvector('english', coalesce(NEW.username, '')) ||
    to_tsvector('spanish', coalesce(NEW.firstname, '')) ||
    to_tsvector('english', coalesce(NEW.firstname, '')) ||
    to_tsvector('spanish', coalesce(NEW.lastname, '')) ||
    to_tsvector('english', coalesce(NEW.lastname, '')) ||
    to_tsvector('spanish', coalesce(NEW.email, '')) ||
    to_tsvector('english', coalesce(NEW.email, '')) ||
    to_tsvector('spanish', coalesce(NEW.country, '')) ||
    to_tsvector('english', coalesce(NEW.country, '')) ||
    to_tsvector('spanish', coalesce(NEW.city, '')) ||
    to_tsvector('english', coalesce(NEW.city, '')) ||
    to_tsvector('spanish', coalesce(NEW.bio, '')) ||
    to_tsvector('english', coalesce(NEW.bio, ''));
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;


 
create or replace function public.create_profile_when_authenticated()
returns trigger as $$
begin
  -- Solo crea perfil si el rol es 'authenticated' y no existe ya
  if new.role = 'authenticated' then
    insert into users.profiles (id, email, username)
    values (
      new.id,
      new.email,
      new.raw_user_meta_data->>'full_name'  -- Extrae el username
    )
    on conflict (id) do nothing;
  end if;
  return new;
end;
$$ language plpgsql security definer;




CREATE OR REPLACE FUNCTION social.refresh_post_content_search()
RETURNS TRIGGER AS $$
DECLARE
  target_post_id uuid;
  hashtag_text TEXT;
  post_title TEXT;
  post_content TEXT;
  new_search tsvector;
  current_search tsvector;
BEGIN
  -- Determinar el ID del post afectado
  IF TG_TABLE_NAME = 'post_hashtags' THEN
    IF TG_OP = 'DELETE' THEN
      target_post_id := OLD.post_id;
    ELSE
      target_post_id := NEW.post_id;
    END IF;
  ELSE
    target_post_id := NEW.id;
  END IF;

  -- Obtener hashtags asociados
  SELECT string_agg(h.name, ' ') INTO hashtag_text
  FROM social.post_hashtags ph
  JOIN social.hashtags h ON h.id = ph.hashtag_id
  WHERE ph.post_id = target_post_id;

  IF hashtag_text IS NULL THEN
    hashtag_text := '';
  END IF;

  -- Obtener título, contenido y content_search actual del post
  SELECT title, content, content_search INTO post_title, post_content, current_search
  FROM social.posts
  WHERE id = target_post_id;

  -- Calcular el nuevo valor del campo content_search
  new_search :=
    to_tsvector('spanish', coalesce(post_title, '') || ' ' || coalesce(post_content, '') || ' ' || hashtag_text) ||
    to_tsvector('english', coalesce(post_title, '') || ' ' || coalesce(post_content, '') || ' ' || hashtag_text);

  -- Actualizar solo si el contenido realmente cambió
  IF current_search IS DISTINCT FROM new_search THEN
    UPDATE social.posts
    SET content_search = new_search
    WHERE id = target_post_id;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION users.update_content_search_roles_trigger()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE users.profiles
  SET content_search_roles = (
    SELECT to_tsvector(
      string_agg(role, ' ')
    )
    FROM music.roles
    WHERE profile_id = NEW.profile_id
  )
  WHERE id = NEW.profile_id;

  RETURN NEW;
END;
$$;




CREATE OR REPLACE FUNCTION social.refresh_profile_content_search_details()
RETURNS TRIGGER AS $$
DECLARE
  target_profile_id uuid;
  hashtag_text TEXT;
  new_search tsvector;
  current_search tsvector;
BEGIN
  -- Determinar el ID del perfil afectado
  IF TG_TABLE_NAME = 'profile_hashtags' THEN
    IF TG_OP = 'DELETE' THEN
      target_profile_id := OLD.profile_id;
    ELSE
      target_profile_id := NEW.profile_id;
    END IF;
  ELSE
    target_profile_id := NEW.id;
  END IF;

  -- Obtener hashtags asociados
  SELECT string_agg(h.name, ' ') INTO hashtag_text
  FROM social.profile_hashtags ph
  JOIN social.hashtags h ON h.id = ph.hashtag_id
  WHERE ph.profile_id = target_profile_id;

  IF hashtag_text IS NULL THEN
    hashtag_text := '';
  END IF;

  -- Obtener el valor actual de content_search_details
  SELECT content_search_details INTO current_search
  FROM users.profiles
  WHERE id = target_profile_id;

  -- Calcular nuevo valor
  new_search :=
    to_tsvector('spanish', hashtag_text) ||
    to_tsvector('english', hashtag_text);

  -- Actualizar solo si hubo cambios
  IF current_search IS DISTINCT FROM new_search THEN
    UPDATE users.profiles
    SET content_search_details = new_search
    WHERE id = target_profile_id;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION users.update_content_search_all()
RETURNS TRIGGER AS $$
BEGIN
  NEW.content_search_all :=
    coalesce(NEW.content_search, '') ||
    coalesce(NEW.content_search_roles, '') ||
    coalesce(NEW.content_search_details, '');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
